/*!
 * meldCX Software Copyright Notice
 *
 * Copyright © 2015 - 2018 by Meldcx Pty Ltd ACN 621 013 410 (meldCX). All Rights Reserved. All
 * materials available by meldCX are protected by copyright and trademark laws of Australia and international
 * treaties.
 *
 * IMPORTANT NOTICE:
 *
 * All computer software, source code, documentation, information or other technical information developed,
 * modified, or enhanced by meldCX is owned by meldCX and its related bodies corporate and is protected by
 * copyright law. You may not distribute, modify, transmit, use or reuse any part of the meldCX’s software
 * without the written consent of meldCX . Unauthorised use, duplication, adaptation, translation, creation of
 * derivative works, disclosure or distribution of meldCX’s software and products, or any portion of them, may
 * result in civil and criminal penalties.
 *
 * meldCX’s software is for meldCX authorised users only. Use of meldCX’s software is subject to the terms of
 * meldCX’s software user license terms. Except as set forth in the software license agreement, all express or
 * implied conditions, representations and warranties, including any implied warranty of merchantability,
 * fitness for a particular purpose, or non-infringement, are disclaimed, except to the extent that such
 * disclaimers are held to be legally invalid.Third party software provided by meldCX is on-provided by meldCX
 * as licensee and is owned by the respective third party identified with that software.
 *
 * meldCX, MELDCX, 3ELD and 3ELDCX are the registered and unregistered trademarks of
 * meldCX and/or its related companies.
 *
 * Meldcx Pty Ltd
 * Level 2, 21 Cremorne Street
 * Richmond VIC 3121
 * Australia
 *
 * Phone: (03) 9998 7630
 * Email: sales@meldcx.com
 * Webpage: www.meldcx.com
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var v1 = __webpack_require__(5);
var v4 = __webpack_require__(7);

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection
var rng;

var crypto = global.crypto || global.msCrypto; // for IE 11
if (crypto && crypto.getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef
  rng = function whatwgRNG() {
    crypto.getRandomValues(rnds8);
    return rnds8;
  };
}

if (!rng) {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);
  rng = function() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

module.exports = rng;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),
/* 2 */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  return bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]];
}

module.exports = bytesToUuid;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(4);


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _uuid = __webpack_require__(0);

var _uuid2 = _interopRequireDefault(_uuid);

var _AgentClientWire = __webpack_require__(8);

var _AgentClientWire2 = _interopRequireDefault(_AgentClientWire);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Agent = function () {
    function Agent(namespace) {
        _classCallCheck(this, Agent);

        var mount = this;
        this.namespace = namespace || 'Agent';
        this._acw = new _AgentClientWire2.default();
        this._acw.setMountpoint(mount);

        window.addEventListener('message', this._handleMessage.bind(this), { once: true });

        this.id = _uuid2.default.v4();

        this.handlingMessage = false;
    }

    _createClass(Agent, [{
        key: '_handleMessage',
        value: function _handleMessage(e) {
            var data = e.data,
                source = e.source,
                origin = e.origin;


            if (this.handlingMessage) return;

            this.handlingMessage = true;

            var name = data.name;


            if (name === this.namespace + '.Init') {
                var _data$parameters = _toArray(data.parameters),
                    manifest = _data$parameters[0],
                    displayId = _data$parameters[1],
                    remoteId = _data$parameters[2],
                    params = _data$parameters.slice(3);

                if (manifest.length && displayId && remoteId) {
                    console.log('params', params);
                    try {
                        this._acw.setManifest(manifest);
                        this._acw.setDisplay(displayId);
                        this._acw.setRemote(remoteId);
                        if (params.length) this._acw.setParams(params);
                        this._acw.setTransport(source, window, origin);
                        this._acw.start();

                        return;
                    } catch (ex) {
                        console.error(ex);
                    }
                }
            }

            this.handlingMessage = false;

            window.addEventListener('message', this._handleMessage.bind(this), { once: true });
        }
    }]);

    return Agent;
}();

exports.default = Agent;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(1);
var bytesToUuid = __webpack_require__(2);

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

// random #'s we need to init node and clockseq
var _seedBytes = rng();

// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
var _nodeId = [
  _seedBytes[0] | 0x01,
  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
];

// Per 4.2.2, randomize (14 bit) clockseq
var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

// Previous uuid creation time
var _lastMSecs = 0, _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};

  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  var node = options.node || _nodeId;
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;


/***/ }),
/* 6 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(1);
var bytesToUuid = __webpack_require__(2);

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options == 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-disable max-len */

var _uuid2 = __webpack_require__(0);

var _uuid3 = _interopRequireDefault(_uuid2);

var _Config = __webpack_require__(9);

var _Config2 = _interopRequireDefault(_Config);

var _Message = __webpack_require__(10);

var _Message2 = _interopRequireDefault(_Message);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AgentClientWire = function () {
    function AgentClientWire() {
        _classCallCheck(this, AgentClientWire);

        this._requests = new Map();
        this._queue = new Set();
        this._ready = false;

        this.sender = null;
        this.receiver = null;
        this.origin = null;
        this.defaultTimeout = 15;
        this.handlers = {};

        this.handlers['AgentClientWireOnReady'] = new Map();
    }

    _createClass(AgentClientWire, [{
        key: 'setMountpoint',
        value: function setMountpoint() {
            var _this = this;

            var mountpoint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            this.mountpoint = mountpoint;

            this.mountpoint.onReady = function (cb) {
                if (_this._ready) {
                    cb();

                    return;
                }

                _this.handlers['AgentClientWireOnReady'].set(_uuid3.default.v4(), cb);
            };

            this.mountpoint.onReadyAsync = function () {
                return new Promise(function (resolve) {
                    _this.mountpoint.onReady(function () {
                        return resolve();
                    });
                });
            };
        }
    }, {
        key: 'setManifest',
        value: function setManifest() {
            var manifest = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            this.manifest = manifest;
        }
    }, {
        key: 'setDisplay',
        value: function setDisplay(displayId) {
            this.displayId = displayId;
        }
    }, {
        key: 'setRemote',
        value: function setRemote(remoteId) {
            this.remoteId = remoteId;
        }
    }, {
        key: 'setParams',
        value: function setParams(params) {
            if (params.length) {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = params[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var _ref2 = _step.value;
                        var name = _ref2.name,
                            value = _ref2.value;

                        this[name] = value;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        }
    }, {
        key: 'setTransport',
        value: function setTransport(sender, receiver, origin) {
            this.sender = sender;
            this.receiver = receiver;
            this.origin = origin;
        }
    }, {
        key: 'start',
        value: function start() {
            var _this2 = this;

            this.receiver.addEventListener('message', this.message.bind(this));

            this._queue.forEach(function (message) {
                _this2.post(message);
                _this2._queue.delete(message);
            });
            this.buildEndpoints(this.manifest, this.mountpoint);

            var initHandlers = Array.from(this.handlers['AgentClientWireOnReady'].values());

            initHandlers.forEach(function (cb) {
                return cb();
            });

            this._ready = true;
        }
    }, {
        key: 'message',
        value: function message(_ref3) {
            var _data = _ref3.data;
            var type = _data.type,
                event = _data.event,
                destination = _data.destination,
                error = _data.error,
                data = _data.data;


            if ((type === 'response' || event === 'response') && this._requests.has(destination)) {
                var _requests$get = this._requests.get(destination),
                    resolve = _requests$get.resolve,
                    reject = _requests$get.reject;

                this._requests.delete(destination);

                if (error) {
                    return reject(error);
                }

                resolve.apply(undefined, _toConsumableArray(data));
            }

            if (event === 'event') {
                if (this.handlers[destination]) {
                    this.handlers[destination].forEach(function (handler) {
                        return handler.apply(undefined, _toConsumableArray(data));
                    });
                }
            }
        }
    }, {
        key: 'post',
        value: function post() {
            var msg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var _msg$message = msg.message,
                message = _msg$message.message,
                transferList = _msg$message.transferList;


            if (window['AgentM.RPC']) {
                var data = JSON.stringify(message);
                window['AgentM.RPC'].fromClient(data);
            }

            if (!this.sender && !window['AgentM.RPC']) return this._queue.add(msg);

            if (this.sender) {
                try {
                    this.sender.postMessage(message, this.origin, transferList);
                } catch (ex) {
                    console.error(ex);
                }
            }
        }
    }, {
        key: 'checkArguments',
        value: function checkArguments(args) {
            return args.every(function (arg) {
                try {
                    switch (true) {
                        case arg instanceof ArrayBuffer:
                            return true;

                        default:
                            JSON.stringify(arg);
                    }

                    return true;
                } catch (ex) {
                    return false;
                }
            });
        }
    }, {
        key: 'timeout',
        value: function timeout(interval) {
            return new Promise(function (resolve, reject) {
                setTimeout(function () {
                    return reject(new Error('Request timed out'));
                }, interval);
            });
        }
    }, {
        key: 'emit',
        value: function emit(source, destination, args) {
            var _this3 = this;

            return new Promise(function (resolve, reject) {
                try {
                    if (!_this3.checkArguments(args)) {
                        reject(new Error('Untransferrable argument provided'));
                    }

                    _this3._requests.set(source, { resolve: resolve, reject: reject });

                    var message = new _Message2.default(source, destination, args, _this3.displayId);

                    _this3.post(message);
                } catch (ex) {
                    return reject(ex);
                }
            });
        }
    }, {
        key: 'notify',
        value: function notify(destination, args, timeout) {
            var _this4 = this;

            var MILLIS = 1000;
            var _uuid = _uuid3.default.v4();
            var config = args.find(function (arg) {
                return arg instanceof _Config2.default;
            });

            var _timeout = timeout;

            if (config) {
                _timeout = config.timeout;
            }

            return Promise.race([this.emit(_uuid, destination, args), this.timeout(_timeout * MILLIS)]).catch(function (ex) {
                if (_this4._requests.has(_uuid)) {
                    _this4._requests.delete(_uuid);
                }
                throw ex;
            });
        }
    }, {
        key: 'getEvaldArgument',
        value: function getEvaldArgument(code, ctx) {
            switch (true) {
                case ctx === 'this':
                    var thisself = this;
                    thisself['__eval'] = function __eval() {
                        'use strict';

                        var val = eval(code);

                        return val;
                    };

                    return thisself['__eval']();

                case ctx === 'window':
                    return window.eval(code);

                default:
                    var self = window[ctx];
                    self['__eval'] = function __eval() {
                        'use strict';

                        return eval(code);
                    };

                    return self['__eval']();
            }
        }
    }, {
        key: 'buildEndpoints',
        value: function buildEndpoints() {
            var _this5 = this;

            var manifest = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var mountpoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            manifest.forEach(function (_ref4) {
                var namespace = _ref4.namespace,
                    properties = _ref4.properties;

                var context = _this5.buildGenerateFromNamespace(mountpoint, namespace);

                properties.forEach(function (property) {
                    var _uuid = property.uuid,
                        _namespace = property.namespace,
                        type = property.type,
                        name = property.name,
                        target = property.target,
                        evaldParams = property.evaldParams;
                    var timeout = property.timeout;


                    timeout = timeout || _this5.defaultTimeout;

                    var _context = _this5.buildGenerateFromNamespace(context, _namespace);

                    // if (_context[name]) return;

                    switch (true) {
                        case type === 'StandardMethod':
                            _context[name] = function () {
                                for (var _len = arguments.length, inArgs = Array(_len), _key = 0; _key < _len; _key++) {
                                    inArgs[_key] = arguments[_key];
                                }

                                var args = inArgs;
                                if (evaldParams) {
                                    if (Array.isArray(evaldParams)) {
                                        var _iteratorNormalCompletion2 = true;
                                        var _didIteratorError2 = false;
                                        var _iteratorError2 = undefined;

                                        try {
                                            for (var _iterator2 = evaldParams[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                                var _ref6 = _step2.value;
                                                var arg = _ref6.arg,
                                                    code = _ref6.code,
                                                    ctx = _ref6.ctx;

                                                if (args[arg - 1]) continue;

                                                if (args.length >= arg) {
                                                    args[arg - 1] = _this5.getEvaldArgument(code, ctx);
                                                }

                                                if (args.length < arg) {
                                                    var length = arg - args.length;
                                                    var padding = Array.from({ length: length });
                                                    args = [].concat(_toConsumableArray(args), _toConsumableArray(padding));
                                                    args[arg - 1] = _this5.getEvaldArgument(code, ctx);
                                                }
                                            }
                                        } catch (err) {
                                            _didIteratorError2 = true;
                                            _iteratorError2 = err;
                                        } finally {
                                            try {
                                                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                                    _iterator2.return();
                                                }
                                            } finally {
                                                if (_didIteratorError2) {
                                                    throw _iteratorError2;
                                                }
                                            }
                                        }
                                    } else if (evaldParams) {
                                        var arg = evaldParams.arg,
                                            code = evaldParams.code,
                                            ctx = evaldParams.ctx;

                                        if (!args[arg - 1]) {
                                            if (args.length >= arg) {
                                                args[arg - 1] = _this5.getEvaldArgument(code, ctx);
                                            }

                                            if (args.length < arg) {
                                                var _length = arg - args.length;
                                                var _padding = Array.from({ length: _length });
                                                args = [].concat(_toConsumableArray(args), _toConsumableArray(_padding));
                                                args[arg - 1] = _this5.getEvaldArgument(code, ctx);
                                            }
                                        }
                                    }
                                }

                                return _this5.notify(_uuid, args, timeout);
                            };
                            break;

                        case type === 'StandardProperty':
                            _context[name] = target;
                            break;

                        case type === 'EvaldMethod':
                            window.eval(target);
                            break;

                        case type === 'EventListener':
                            _this5.handlers[name] = new Map();

                            _context[name] = function (_handler) {
                                var _options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

                                var id = _uuid3.default.v4();
                                _this5.handlers[name].set(id, function () {
                                    if (_options.once) {
                                        _this5.handlers[name].delete(id);
                                    }

                                    return _handler.apply(undefined, arguments);
                                });

                                // Drop the un-subscriber
                                return function () {
                                    _this5.handlers[name].delete(id);
                                };
                            };
                            break;
                    }
                });
            });
        }
    }, {
        key: 'buildGenerateFromNamespace',
        value: function buildGenerateFromNamespace() {
            var mount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var _namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '/';

            var namespace = _namespace.replace('/Agent', '');
            if (namespace === '/') return mount;

            var names = namespace.split('/').reverse().filter(function (name) {
                return name;
            });

            var build = function build(context) {
                var name = names.pop();

                if (name) {
                    context[name] = context[name] || {};
                }

                if (context[name] && names.length > 0) {
                    return build(context[name]);
                }

                return context[name];
            };

            return build(mount);
        }
    }]);

    return AgentClientWire;
}();

exports.default = AgentClientWire;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Config = function Config() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Config);

    Object.assign(this, config);
};

exports.default = Config;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Message = function () {
    function Message(source, destination, args, displayId) {
        _classCallCheck(this, Message);

        this.source = source;
        this.destination = destination;
        this.arguments = args;
        this.displayId = displayId;
    }

    _createClass(Message, [{
        key: "setSource",
        value: function setSource(source) {
            this.source = source;
        }
    }, {
        key: "setDestination",
        value: function setDestination(destination) {
            this.destination = destination;
        }
    }, {
        key: "setArguments",
        value: function setArguments(args) {
            this.arguments = args;
        }
    }, {
        key: "setDisplay",
        value: function setDisplay(displayId) {
            this.displayId = displayId;
        }
    }, {
        key: "message",
        get: function get() {
            var source = this.source,
                destination = this.destination,
                _arguments = this.arguments,
                displayId = this.displayId;


            return {
                message: { source: source, destination: destination, arguments: _arguments, displayId: displayId }
            };
        }
    }]);

    return Message;
}();

exports.default = Message;

/***/ })
/******/ ]);
//# sourceMappingURL=Agent.js.map